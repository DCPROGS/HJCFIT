#ifndef DCPROGS_CONFIG_H
#define DCPROGS_CONFIG_H

#include <iso646.h>
#include <Eigen/Dense>

#cmakedefine HAS_CXX11_TYPETRAITS
#cmakedefine HAS_CXX11_TRIVIALTYPETRAITS
#cmakedefine HAS_CXX11_CONSTEXPR
#cmakedefine noexcept throw()
#cmakedefine MSWINDOBE __declspec(dllimport)
#cmakedefine HAS_CXX11_CONSTEXPR
#cmakedefine HAS_CXX11_RANDOM_DEVICE
#cmakedefine HAS_CXX11_UNIQUE_PTR

#ifdef HAS_CXX11_CONSTEXPR
# define DCPROGS_INIT_CONSTEXPR(TYPEANDNAME, VALUE) constexpr static TYPEANDNAME = VALUE
# define DCPROGS_DECL_CONSTEXPR(TYPEANDNAME, VALUE) constexpr TYPEANDNAME
#else 
# define DCPROGS_INIT_CONSTEXPR(TYPEANDNAME, VALUE) const static TYPEANDNAME
# define DCPROGS_DECL_CONSTEXPR(TYPEANDNAME, VALUE) const TYPEANDNAME = VALUE
#endif

// one should alway known when one is working on crapware
#cmakedefine MSVC


#if defined(MSWINDOBE) && defined(DCPROGS_LIKELIHOOD_DLLEXPORT)
# undef MSWINDOBE
# define MSWINDOBE __declspec(dllexport)
#endif
#ifndef MSWINDOBE 
# define MSWINDOBE
#endif

#cmakedefine DCPROGS_PYTHON_BINDINGS
#cmakedefine DCPROGS_NPY_LONG_DOUBLE
#cmakedefine DCPROGS_NPY_BOOL
#cmakedefine DCPROGS_NPY_ARRAY
#cmakedefine DCPROGS_NPY_ENABLEFLAGS
#cmakedefine NUMPY_VERSION_MAJOR @NUMPY_VERSION_MAJOR@
#cmakedefine NUMPY_VERSION_MINOR @NUMPY_VERSION_MINOR@


#cmakedefine CXX_HAS_STD_ISNAN
#cmakedefine CXX_HAS_ISNAN
#cmakedefine CXX_HAS__ISNAN
#cmakedefine CXX_HAS_FLOAT_H_ISNAN
#ifdef CXX_HAS_STD_ISNAN
#  include <cmath>
#  define DCPROGS_ISNAN(X) std::isnan(X)
#elif defined(CXX_HAS_ISNAN)
#  include <math.h>
#  define DCPROGS_ISNAN(X) ::isnan(X)
#elif defined CXX_HAS___ISNAN
#  include <math.h>
#  define DCPROGS_ISNAN(X) __isnan(X)
#elif defined(CXX_HAS_FLOAT_H_ISNAN)
#  include <float.h>
#  define DCPROGS_ISNAN(X) _isnan(X)
#else
#  error no macro defined for isnan
#endif

#cmakedefine DCPROGS_LONG_DOUBLE

namespace DCProgs {
# ifdef DCPROGS_LONG_DOUBLE
    //! Types of reals across DCProgs.
    typedef long double t_real;
# else
    //! Types of reals across DCProgs.
    typedef double t_real;
# endif
  //! Complex real type
  typedef std::complex<t_real> t_complex;
  //! Types of integers across DCProgs.
  typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE t_int;
  //! Types of real matrices across DCProgs.
  typedef Eigen::Matrix<t_real, ::Eigen::Dynamic, ::Eigen::Dynamic> t_rmatrix;
  //! Types of boolean matrices across DCProgs.
  typedef Eigen::Matrix<bool, ::Eigen::Dynamic, ::Eigen::Dynamic> t_bmatrix;
  //! Types of initial state vectors across DCProgs.
  typedef Eigen::Matrix<t_real, 1, ::Eigen::Dynamic> t_initvec;
  //! Types of final state vectors across DCProgs.
  typedef Eigen::Matrix<t_real, ::Eigen::Dynamic, 1> t_finivec;
  //! Type for a vector. 
  typedef t_finivec t_rvector;
  //! Type of complex matrices.
  typedef Eigen::Matrix<t_complex, ::Eigen::Dynamic, ::Eigen::Dynamic> t_cmatrix;
  //! Type of complex vectors.
  typedef Eigen::Matrix<t_complex, ::Eigen::Dynamic, 1> t_cvector;

  // Some functions that come in usefull left and right.
  template<class T>
    auto numpy_io(Eigen::DenseBase<T> const &_matrix)
                   -> decltype(_matrix.format(Eigen::IOFormat()))  {
      return _matrix.format(Eigen::IOFormat(Eigen::FullPrecision, 0, ", ", ",\n",
                                            "[", "]", "[", "]"));
    }

  template<class T>
    bool eigen_nan(Eigen::DenseBase<T> const &_matrix) {
      for(typename Eigen::DenseBase<T>::Index i(0); i < _matrix.rows(); ++i)
        for(typename Eigen::ArrayBase<T>::Index j(0); j < _matrix.cols(); ++j)
           if(DCPROGS_ISNAN(_matrix(i, j))) return true;
      return false;
    }
}
#endif
